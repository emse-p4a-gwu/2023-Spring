<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Final Review</title>
    <meta charset="utf-8" />
    <meta name="author" content="John Paul Helveston" />
    <meta name="date" content="2023-05-04" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/shareon/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain/shareagain.js"></script>
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <meta name="description" content="EMSE 4571: Intro to Programming for Analytics"/>
    <meta name="generator" content="xaringan and remark.js"/>
    <meta name="github-repo" content="emse-p4a-gwu/2023-Spring"/>
    <meta name="twitter:title" content="Final Review"/>
    <meta name="twitter:description" content="EMSE 4571: Intro to Programming for Analytics"/>
    <meta name="twitter:url" content="https://p4a.seas.gwu.edu/2023-Spring/"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:creator" content="@johnhelveston"/>
    <meta name="twitter:site" content="@johnhelveston"/>
    <meta property="og:title" content="Final Review"/>
    <meta property="og:description" content="EMSE 4571: Intro to Programming for Analytics"/>
    <meta property="og:url" content="https://p4a.seas.gwu.edu/2023-Spring/"/>
    <meta property="og:type" content="website"/>
    <meta property="og:locale" content="en_US"/>
    <meta property="article:author" content="John Paul Helveston"/>
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <link rel="stylesheet" href="css/lexis.css" type="text/css" />
    <link rel="stylesheet" href="css/lexis-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">





class: middle, inverse

.leftcol30[

&lt;center&gt;
&lt;img src="https://github.com/emse-p4a-gwu/emse-p4a-gwu.github.io/raw/master/images/p4a_hex_sticker.png" width=250&gt;
&lt;/center&gt;

]

.rightcol70[

# Week 14: .fancy[Final Review]

### <svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:white;overflow:visible;position:relative;"><path d="M243.4 2.6l-224 96c-14 6-21.8 21-18.7 35.8S16.8 160 32 160v8c0 13.3 10.7 24 24 24H456c13.3 0 24-10.7 24-24v-8c15.2 0 28.3-10.7 31.3-25.6s-4.8-29.9-18.7-35.8l-224-96c-8.1-3.4-17.2-3.4-25.2 0zM128 224H64V420.3c-.6 .3-1.2 .7-1.8 1.1l-48 32c-11.7 7.8-17 22.4-12.9 35.9S17.9 512 32 512H480c14.1 0 26.5-9.2 30.6-22.7s-1.1-28.1-12.9-35.9l-48-32c-.6-.4-1.2-.7-1.8-1.1V224H384V416H344V224H280V416H232V224H168V416H128V224zm128-96c-17.7 0-32-14.3-32-32s14.3-32 32-32s32 14.3 32 32s-14.3 32-32 32z"/></svg> EMSE 4571: Intro to Programming for Analytics
### <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:white;overflow:visible;position:relative;"><path d="M272 304h-96C78.8 304 0 382.8 0 480c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32C448 382.8 369.2 304 272 304zM48.99 464C56.89 400.9 110.8 352 176 352h96c65.16 0 119.1 48.95 127 112H48.99zM224 256c70.69 0 128-57.31 128-128c0-70.69-57.31-128-128-128S96 57.31 96 128C96 198.7 153.3 256 224 256zM224 48c44.11 0 80 35.89 80 80c0 44.11-35.89 80-80 80S144 172.1 144 128C144 83.89 179.9 48 224 48z"/></svg> John Paul Helveston
### <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:white;overflow:visible;position:relative;"><path d="M152 64H296V24C296 10.75 306.7 0 320 0C333.3 0 344 10.75 344 24V64H384C419.3 64 448 92.65 448 128V448C448 483.3 419.3 512 384 512H64C28.65 512 0 483.3 0 448V128C0 92.65 28.65 64 64 64H104V24C104 10.75 114.7 0 128 0C141.3 0 152 10.75 152 24V64zM48 448C48 456.8 55.16 464 64 464H384C392.8 464 400 456.8 400 448V192H48V448z"/></svg> May 04, 2023

]



---

# Format: 2-part exam

.leftcol[

## Part 1

- Hand-written exam (like midterm).
- You may use a single 8.5 x 11 sheet of notes.
- No calculators, no books, no computers, no phones, no internet.

]

.rightcol[

## Part 2 (data analysis)

- Need your laptop (make sure it's charged!). 
- Can only start Part 2 after turning in Part 1.
- You may use RStudio, the course website, and chatGPT.

]

---

# What's on the final? 

## Comprehensive, except for Webscraping &amp; Monte Carlo

.leftcol[

## Part 1

- 10 True / False questions.
- 4 Short answer questions.
- Hand-write one function and test function.

]

.rightcol[

## Part 2

- Read in a dataset. 
- Answer questions about the data (using tidyverse tools).
- Make a visualization about the data.
- Bonus: Scrape a website.

]

---

# Zero tolerance policy on cheating

Reasons to not cheat:

- Evidence of working with another person on the final results in a 0 for all individuals involved (and I'll push for class failure too).
- It's sooooooo easy to tell if you cheated (trust me, I'll know).
- I'm letting you use chatGPT for part 2!
- I'm a pretty soft grader anyway (you'll get 50% for just _trying_!).

---

# Things to review

--

- Lecture slides, especially practice puzzles covered in class)

--

- Previous quizzes

--

- Memorize syntax for:

  - operators (e.g. mod `%%` and integer division `%/%`)
  - "number choping" 
  - if / else statements
  - loops
  - functions
  - test functions
  - dplyr functions (`select`, `filter`, `mutate`, `arrange`, `group_by`, `summarise`)
  - How to use ggplot

---



class: inverse, middle

# Week 14: .fancy[Final Review]

### 1. Programming
### 2. Data Analytics

---



class: inverse, middle

# Week 14: .fancy[Final Review]

### 1. .orange[Programming]
### 2. Data Analytics

---

class: middle, inverse, center 

# .fancy[Basics]

---

## Operators: Relational (`=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`) and Logical (`&amp;`, `|`, `!`)


```r
x &lt;- FALSE
y &lt;- FALSE
z &lt;- TRUE
```

a Write a logical statement that compares the objects `x`, `y`, and `z` and returns `TRUE`

b) Fill in **relational** operators to make this statement return `TRUE`:

`! (x __ y) &amp; ! (z __ y)`

c) Fill in **logical** operators to make this statement return `FALSE`:

`! (x __ y) | (z __ y)`

---

# Numeric Data

--

.leftcol[

Doubles:


```r
typeof(3.14)
```

```
#&gt; [1] "double"
```

]

--

.rightcol[

"Integers":


```r
typeof(3)
```

```
#&gt; [1] "double"
```

]

---

# Actual Integers

--

Check if a number is an "integer":

--

.leftcol[


```r
n &lt;- 3
is.integer(n) # Doesn't work!
```

```
#&gt; [1] FALSE
```

]

--

.rightcol[


```r
n == as.integer(n) # Compare n to a converted version of itself
```

```
#&gt; [1] TRUE
```

]

---

# Logical Data

`TRUE` or `FALSE`

--


```r
x &lt;- 1
y &lt;- 2
```

--


```r
x &gt; y # Is x greater than y?
```

```
#&gt; [1] FALSE
```

--


```r
x == y
```

```
#&gt; [1] FALSE
```

---

## Tricky data type stuff

--

.leftcol[

Logicals become numbers when doing math


```r
TRUE + 1 # TRUE becomes 1
```

```
#&gt; [1] 2
```


```r
FALSE + 1 # FALSE becomes 0
```

```
#&gt; [1] 1
```

]

--

.rightcol[

Be careful of accidental strings


```r
typeof("3.14")
```

```
#&gt; [1] "character"
```

```r
typeof("TRUE")
```

```
#&gt; [1] "character"
```

]

---

# Integer division: `%/%`

Integer division drops the remainder

--


```r
4 / 3 # Regular division
```

```
#&gt; [1] 1.333333
```

```r
4 %/% 3 # Integer division
```

```
#&gt; [1] 1
```

---

# Integer division: `%/%`

Integer division drops the remainder

--

What will this return?


```r
4 %/% 4
```

--


```
#&gt; [1] 1
```

--

What will this return?


```r
4 %/% 5
```

--


```
#&gt; [1] 0
```

---

# Modulus operator: `%%`

Modulus returns the remainder _after_ doing integer division

--


```r
5 %% 3
```

```
#&gt; [1] 2
```

--


```r
3.1415 %% 3
```

```
#&gt; [1] 0.1415
```

---

# Modulus operator: `%%`

Modulus returns the remainder _after_ doing integer division

--

What will this return?


```r
4 %% 4
```

--


```
#&gt; [1] 0
```

--

What will this return?


```r
4 %% 5
```

--


```
#&gt; [1] 4
```

---

## Number "chopping" with 10s (only works with `n &gt; 0`)

--
.pull-left[
The mod operator (`%%`) "chops" a number and returns everything to the _right_


```r
123456 %% 1
```

```
#&gt; [1] 0
```

```r
123456 %% 10
```

```
#&gt; [1] 6
```

```r
123456 %% 100
```

```
#&gt; [1] 56
```
]
--
.pull-right[
Integer division (`%/%`) "chops" a number and returns everything to the _left_


```r
123456 %/% 1
```

```
#&gt; [1] 123456
```

```r
123456 %/% 10
```

```
#&gt; [1] 12345
```

```r
123456 %/% 100
```

```
#&gt; [1] 1234
```
]

---

class: middle, inverse, center 

# .fancy[Functions]

---

# Basic function syntax

.code90[

```r
functionName &lt;- function(arguments) {
    # Do stuff here
    return(something)
}
```
]

---

# Basic function syntax

In English:

&gt; "`functionName` is a `function` of `arguments` that does..."

.code90[

```r
functionName &lt;- function(arguments) {
    # Do stuff here
    return(something)
}
```
]

---

# Basic function syntax

Example:

&gt; "`squareRoot` is a `function` of `n` that...returns the square root of `n`"


```r
squareRoot &lt;- function(n) {
    return(n^0.5)
}
```

--


```r
squareRoot(64)
```

```
#&gt; [1] 8
```

---

# Test function "syntax"

--

.leftcol[

### Function:


```r
functionName &lt;- function(arguments) {
    # Do stuff here
    return(something)
}
```

]

--

.rightcol[

### Test function:


```r
test_functionName &lt;- function() {
    cat("Testing functionName()...")
    # Put test cases here
    cat("Passed!\n")
}
```

]

---

# Writing test cases with `stopifnot()`

`stopifnot()` stops the function if whatever is inside the `()` is not `TRUE`.

--

.leftcol[

### Function:


```r
isEven &lt;- function(n) {
    return((n %% 2) == 0)
}
```

- `isEven(1)` should be `FALSE`
- `isEven(2)` should be `TRUE`
- `isEven(-7)` should be `FALSE`

]

--

.rightcol[

### Test function:


```r
test_isEven &lt;- function() {
    cat("Testing isEven()...")
    stopifnot(isEven(1) == FALSE)
    stopifnot(isEven(2) == TRUE)
    stopifnot(isEven(-7) == FALSE)
    cat("Passed!\n")
}
```

]

---

# When testing _numbers_, use `almostEqual()`

--

.leftcol[

Rounding errors can cause headaches:


```r
x &lt;- 0.1 + 0.2
x
```

```
#&gt; [1] 0.3
```

```r
x == 0.3
```

```
#&gt; [1] FALSE
```

```r
print(x, digits = 20)
```

```
#&gt; [1] 0.30000000000000004441
```

]

--

.rightcol[

Define a function that checks if two values are _almost_ the same:


```r
almostEqual &lt;- function(n1, n2, threshold = 0.00001) {
    return(abs(n1 - n2) &lt;= threshold)
}
```


```r
x &lt;- 0.1 + 0.2
almostEqual(x, 0.3)
```

```
#&gt; [1] TRUE
```

]

---

## Make sure you know how to write `almostEqual()`

.leftcol70[


```r
almostEqual &lt;- function(n1, n2, threshold = 0.00001) {
    return(abs(n1 - n2) &lt;= threshold)
}
```

]

---

class: middle, inverse, center 

# .fancy[Conditionals]

---

# Use `if` statements to filter function inputs

Example: Write the function `isEvenNumber(n)` that returns `TRUE` if `n` is an even number and `FALSE` otherwise. **If `n` is not a number, the function should return `FALSE`**.

--

.leftcol40[


```r
isEvenNumber &lt;- function(n) {
    return((n %% 2) == 0)
}
```


```r
isEvenNumber(2)
```

```
#&gt; [1] TRUE
```

```r
isEvenNumber("not_a_number")
```

```
#&gt; Error in n%%2: non-numeric argument to binary operator
```

]

--

.rightcol60[


```r
isEvenNumber &lt;- function(n) {
*   if (! is.numeric(n)) { return(FALSE) }
    return((n %% 2) == 0)
}
```


```r
isEvenNumber(2)
```

```
#&gt; [1] TRUE
```

```r
isEvenNumber("not_a_number")
```

```
#&gt; [1] FALSE
```

]

---

class: middle, inverse, center 

# .fancy[Loops]

---

.leftcol[

### Use `for` loops when the number of iterations is **_known_**.

1. Build the sequence
2. Iterate over it


```r
*for (i in 1:5) { # Define the sequence
    cat(i, '\n')
}
```

```
#&gt; 1 
#&gt; 2 
#&gt; 3 
#&gt; 4 
#&gt; 5
```

]

--

.rightcol[

### Use `while` loops when the number of iterations is **_unknown_**.

1. Define stopping condition
2. Manually increase condition


```r
i &lt;- 1
*while (i &lt;= 5) { # Define stopping condition
    cat(i, '\n')
*   i &lt;- i + 1 # Increase condition
}
```

```
#&gt; 1 
#&gt; 2 
#&gt; 3 
#&gt; 4 
#&gt; 5
```

]

---

## Search for something in a sequence

Example: count the **even** numbers in sequence: `1, (2), 3, (4), 5`

--

.leftcol[

### `for` loop


```r
*count &lt;- 0 # Initialize count
for (i in seq(5)) {
*   if (i %% 2 == 0) {
*       count &lt;- count + 1 # Update
*   }
}
```


```r
count
```

```
#&gt; [1] 2
```

]

--

.rightcol[

### `while` loop


```r
*count &lt;- 0 # Initialize count
i &lt;- 1
while (i &lt;= 5) {
*   if (i %% 2 == 0) {
*       count &lt;- count + 1 # Update
*   }
    i &lt;- i + 1
}
```


```r
count
```

```
#&gt; [1] 2
```

]
---

class: middle, inverse, center 

# .fancy[Vectors]

---

# The universal vector generator: `c()`

--

.cols3[

## Numeric vectors


```r
x &lt;- c(1, 2, 3)
x
```

```
#&gt; [1] 1 2 3
```

]

--

.cols3[

## Character vectors


```r
y &lt;- c('a', 'b', 'c')
y
```

```
#&gt; [1] "a" "b" "c"
```

]

--

.cols3[

## Logical vectors

```r
z &lt;- c(TRUE, FALSE, TRUE)
z
```

```
#&gt; [1]  TRUE FALSE  TRUE
```

]

---

# Elements in vectors must be the same type

### Type hierarchy:

- `character` &gt; `numeric` &gt; `logical`
- `double` &gt; `integer`

--

.cols3[

Coverts to characters:


```r
c(1, "foo", TRUE)
```

```
#&gt; [1] "1"    "foo"  "TRUE"
```

]

--

.cols3[

Coverts to numbers:


```r
c(7, TRUE, FALSE)
```

```
#&gt; [1] 7 1 0
```

]

--

.cols3[

Coverts to double:


```r
c(1L, 2, pi)
```

```
#&gt; [1] 1.000000 2.000000 3.141593
```

]

---

# Most functions operate on vector _elements_

--


```r
x &lt;- c(3.14, 7, 10, 15)
```

--


```r
round(x)
```

```
#&gt; [1]  3  7 10 15
```

--


```r
isEven &lt;- function(n) {
    return((n %% 2) == 0)
}
```


```r
isEven(x)
```

```
#&gt; [1] FALSE FALSE  TRUE FALSE
```

---

## "Summary" functions **return one value**

--


```r
x &lt;- c(3.14, 7, 10, 15)
```

--

.leftcol[


```r
length(x)
```

```
#&gt; [1] 4
```

```r
sum(x)
```

```
#&gt; [1] 35.14
```

```r
prod(x)
```

```
#&gt; [1] 3297
```

]

.rightcol[


```r
min(x)
```

```
#&gt; [1] 3.14
```

```r
max(x)
```

```
#&gt; [1] 15
```

```r
mean(x)
```

```
#&gt; [1] 8.785
```

]

---

# Use brackets `[]` to get elements from a vector


```r
x &lt;- seq(1, 10)
```

--

.leftcol[.code80[

Indices start at 1:


```r
x[1] # Returns the first element
```

```
#&gt; [1] 1
```


```r
x[3] # Returns the third element
```

```
#&gt; [1] 3
```


```r
x[length(x)] # Returns the last element
```

```
#&gt; [1] 10
```

]]

--

.rightcol[.code80[

Slicing with a vector of indices:


```r
x[1:3]  # Returns the first three elements
```

```
#&gt; [1] 1 2 3
```

```r
x[c(2, 7)] # Returns the 2nd and 7th elements
```

```
#&gt; [1] 2 7
```

]]

---

# Use negative integers to _remove_ elements


.code70[


```r
x &lt;- seq(1, 10)
```

]

--

.code70[


```r
x[-1] # Drops the first element
```

```
#&gt; [1]  2  3  4  5  6  7  8  9 10
```

```r
x[-1:-3] # Drops the first three elements
```

```
#&gt; [1]  4  5  6  7  8  9 10
```

```r
x[-c(2, 7)] # Drops the 2nd and 7th elements
```

```
#&gt; [1]  1  3  4  5  6  8  9 10
```

```r
x[-length(x)] # Drops the last element
```

```
#&gt; [1] 1 2 3 4 5 6 7 8 9
```

]

---

# Slicing with logical indices

--


```r
x &lt;- seq(1, 20, 3)
x
```

```
#&gt; [1]  1  4  7 10 13 16 19
```

--


```r
x &gt; 10 # Create a logical vector based on some condition
```

```
#&gt; [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE
```

--

Slice `x` with logical vector - only `TRUE` elements will be returned:


```r
x[x &gt; 10]
```

```
#&gt; [1] 13 16 19
```

---

# Comparing vectors

Check if 2 vectors are the same:


```r
x &lt;- c(1, 2, 3)
y &lt;- c(1, 2, 3)
```


```r
x == y
```

--


```
#&gt; [1] TRUE TRUE TRUE
```

---

# Comparing vectors with `all()` and `any()`

--

.leftcol[

`all()`: Check if _all_ elements are the same

```r
x &lt;- c(1, 2, 3)
y &lt;- c(1, 2, 3)
all(x == y)
```

```
#&gt; [1] TRUE
```


```r
x &lt;- c(1, 2, 3)
y &lt;- c(-1, 2, 3)
all(x == y)
```

```
#&gt; [1] FALSE
```

]

--

.rightcol[

`any()`: Check if _any_ elements are the same


```r
x &lt;- c(1, 2, 3)
y &lt;- c(1, 2, 3)
any(x == y)
```

```
#&gt; [1] TRUE
```


```r
x &lt;- c(1, 2, 3)
y &lt;- c(-1, 2, 3)
any(x == y)
```

```
#&gt; [1] TRUE
```

]

---

class: middle, inverse, center 

# .fancy[Strings]

---

class: center

## Case conversion &amp; substrings

|Function         |  Description                            |
|:----------------|:----------------------------------------|
|`str_to_lower()` | converts string to lower case           |
|`str_to_upper()` | converts string to upper case           |
|`str_to_title()` | converts string to title case           |
|`str_length()`   | number of characters                    |
|`str_sub()`      | extracts substrings                     |
|`str_locate()`   | returns indices of substrings           |
|`str_dup()`      | duplicates characters                   |

---

# Quick practice:

<div class="countdown" id="timer_2b3cb710" data-warn-when="30" data-update-every="1" tabindex="0" style="top:0;right:0;font-size:2em;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

Create this string object: 


```r
x &lt;- 'thisIsGoodPractice'
```

Then use **stringr** functions to transform `x` into the following strings:

.leftcol[

- `'thisIsGood'`
- `'practice'`
- `'GOOD'`
- `'thisthisthis'`
- `'GOODGOODGOOD'`

]

.rightcol[

**Hint**: You'll need these:

- `str_to_lower()`
- `str_to_upper()`
- `str_locate()`
- `str_sub()`
- `str_dup()`

]

---

class: center

## Padding, splitting, &amp; merging

|Function         |  Description                            |
|:----------------|:----------------------------------------|
|`str_trim()`     | removes leading and trailing whitespace |
|`str_pad()`      | pads a string                           |
|`paste()`        | string concatenation                    |
|`str_split()`    | split a string into a vector            |

---

## Quick practice:

<div class="countdown" id="timer_67ac23ca" data-warn-when="30" data-update-every="1" tabindex="0" style="top:0;right:0;font-size:2em;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

.font90[

Create the following objects:


```r
x &lt;- 'this_is_good_practice'
y &lt;- c('hello', 'world')
```

Use `stringr` functions to transform `x` and `y` into the following:

.leftcol60[

- `"hello world"`
- `"***hello world***"`
- `c("this", "is", "good", "practice")`
- `"this is good practice"`
- `"hello world, this is good practice"`

]

.rightcol40[

**Hint**: You'll need these:

- `str_trim()`
- `str_pad()`
- `paste()`
- `str_split()`

]]

---

class: center

## Detecting &amp; replacing

|Function         |  Description                            |
|:----------------|:----------------------------------------|
|`str_sort()`     | sort a string alphabetically            |
|`str_order()`    | get the order of a sorted string        |
|`str_detect()`   | match a string in another string        |
|`str_replace()`  | replace a string in another string      |

---

# Quick practice:

<div class="countdown" id="timer_aca4aa3f" data-warn-when="30" data-update-every="1" tabindex="0" style="top:0;right:0;font-size:2em;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>


```r
fruit[1:5]
```

```
#&gt; [1] "apple"       "apricot"     "avocado"     "banana"      "bell pepper"
```

Use `stringr` functions to answer the following questions about the  `fruit` vector:

1. How many fruit have the string `"rr"` in it?
2. Which fruit end with string `"fruit"`?
3. Which fruit contain more than one `"o"` character?

**Hint**: You'll need to use `str_detect()` and `str_count()`

---



class: inverse, middle

# Week 14: .fancy[Final Review]

### 1. Programming
### 2. .orange[Data Analytics]

---

class: inverse, center, middle

# Data Frame Basics

---

## **Columns**: _Vectors_ of values (must be same data type)


```r
beatles
```

```
#&gt; # A tibble: 4 × 5
#&gt;   firstName lastName  instrument yearOfBirth deceased
#&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;            &lt;dbl&gt; &lt;lgl&gt;   
#&gt; 1 John      Lennon    guitar            1940 TRUE    
#&gt; 2 Paul      McCartney bass              1942 FALSE   
#&gt; 3 Ringo     Starr     drums             1940 FALSE   
#&gt; 4 George    Harrison  guitar            1943 TRUE
```

--

Extract a column using `$`


```r
beatles$firstName
```

```
#&gt; [1] "John"   "Paul"   "Ringo"  "George"
```

---

# Create new variables with the `$` symbol

--

Add the hometown of the bandmembers:


```r
beatles$hometown &lt;- 'Liverpool'
beatles
```

```
#&gt; # A tibble: 4 × 6
#&gt;   firstName lastName  instrument yearOfBirth deceased hometown 
#&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;            &lt;dbl&gt; &lt;lgl&gt;    &lt;chr&gt;    
#&gt; 1 John      Lennon    guitar            1940 TRUE     Liverpool
#&gt; 2 Paul      McCartney bass              1942 FALSE    Liverpool
#&gt; 3 Ringo     Starr     drums             1940 FALSE    Liverpool
#&gt; 4 George    Harrison  guitar            1943 TRUE     Liverpool
```

---

## **Rows**: Information about individual observations

--

Information about _John Lennon_ is in the first row:


```r
beatles[1,]
```

```
#&gt; # A tibble: 1 × 6
#&gt;   firstName lastName instrument yearOfBirth deceased hometown 
#&gt;   &lt;chr&gt;     &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt; &lt;lgl&gt;    &lt;chr&gt;    
#&gt; 1 John      Lennon   guitar            1940 TRUE     Liverpool
```

--

Information about _Paul McCartney_ is in the second row:


```r
beatles[2,]
```

```
#&gt; # A tibble: 1 × 6
#&gt;   firstName lastName  instrument yearOfBirth deceased hometown 
#&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;            &lt;dbl&gt; &lt;lgl&gt;    &lt;chr&gt;    
#&gt; 1 Paul      McCartney bass              1942 FALSE    Liverpool
```

---

## Access elements by index: `DF[row, column]`



General form for indexing elements:


```r
DF[row, column]
```

--

.leftcol[

Select the element in row 1, column 2:


```r
beatles[1, 2]
```

```
#&gt; # A tibble: 1 × 1
#&gt;   lastName
#&gt;   &lt;chr&gt;   
#&gt; 1 Lennon
```

]

--

.rightcol[

Select the elements in rows 1 &amp; 2 and columns 2 &amp; 3:


```r
beatles[c(1, 2), c(2, 3)]
```

```
#&gt; # A tibble: 2 × 2
#&gt;   lastName  instrument
#&gt;   &lt;chr&gt;     &lt;chr&gt;     
#&gt; 1 Lennon    guitar    
#&gt; 2 McCartney bass
```

]

---

# Steps to importing external data files

--

## 1. Create a path to the data


```r
library(here)
*pathToData &lt;- here('data', 'data.csv')
pathToData
```

```
#&gt; [1] "/Users/jhelvy/gh/teaching/P4A/2023-Spring/class/14-final-review/data/data.csv"
```

--

## 2. Import the data


```r
library(readr)
*df &lt;- read_csv(pathToData)
```

---

class: inverse, center, middle

# Data Wrangling

---

class: center

### The tidyverse: `stringr` + `dplyr` + `readr` +  `ggplot2` + ...

&lt;center&gt;
&lt;img src="images/horst_monsters_tidyverse.jpeg" width="950"&gt;
&lt;/center&gt;Art by [Allison Horst](https://www.allisonhorst.com/)

---

# **Know how to use these functions!**

- `select()`: subset columns
- `filter()`: subset rows on conditions
- `arrange()`: sort data frame
- `mutate()`: create new columns by using information from other columns
- `group_by()`: group data to perform grouped operations
- `summarize()`: create summary statistics (usually on grouped data)
- `count()`: count discrete rows

---

# Select columns with `select()`

&lt;br&gt;
&lt;center&gt;
&lt;img src="images/rstudio-cheatsheet-select.png" width="900"&gt;
&lt;/center&gt;

---

# Select columns with `select()`


```r
spicegirls %&gt;% 
    select(firstName, lastName)
```

```
#&gt; # A tibble: 5 × 2
#&gt;   firstName lastName 
#&gt;   &lt;chr&gt;     &lt;chr&gt;    
#&gt; 1 Melanie   Brown    
#&gt; 2 Melanie   Chisholm 
#&gt; 3 Emma      Bunton   
#&gt; 4 Geri      Halliwell
#&gt; 5 Victoria  Beckham
```

---

# Select rows with `filter()`

&lt;br&gt;
&lt;center&gt;
&lt;img src="images/rstudio-cheatsheet-filter.png" width="900"&gt;
&lt;/center&gt;

---

# Select rows with `filter()`

Example: Filter the band members born after 1974


```r
spicegirls %&gt;% 
    filter(yearOfBirth &gt; 1974)
```

```
#&gt; # A tibble: 2 × 5
#&gt;   firstName lastName spice yearOfBirth deceased
#&gt;   &lt;chr&gt;     &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;lgl&gt;   
#&gt; 1 Melanie   Brown    Scary        1975 FALSE   
#&gt; 2 Emma      Bunton   Baby         1976 FALSE
```

---

# Removing missing values

Drop all rows where `variable` is `NA`


```r
data %&gt;% 
    filter(!is.na(variable))
```

---

# **Don't make this common mistake!**

.leftcol[

## Wrong! 


```r
data %&gt;% 
  filter(data, condition)
```

]

.rightcol[

## Right! 


```r
data %&gt;% 
  filter(condition)
```

Or: 


```r
filter(data, condition)
```

]

---

class: center, middle

## Create new variables with `mutate()`

&lt;br&gt;
&lt;center&gt;
&lt;img src="images/rstudio-cheatsheet-mutate.png" width="900"&gt;
&lt;/center&gt;

---

# Create new variables with `mutate()`

Example: Use the `yearOfBirth` variable to compute the age of each band member


```r
spicegirls %&gt;%
    mutate(age = 2022 - yearOfBirth)
```

```
#&gt; # A tibble: 5 × 6
#&gt;   firstName lastName  spice  yearOfBirth deceased   age
#&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt; &lt;lgl&gt;    &lt;dbl&gt;
#&gt; 1 Melanie   Brown     Scary         1975 FALSE       47
#&gt; 2 Melanie   Chisholm  Sporty        1974 FALSE       48
#&gt; 3 Emma      Bunton    Baby          1976 FALSE       46
#&gt; 4 Geri      Halliwell Ginger        1972 FALSE       50
#&gt; 5 Victoria  Beckham   Posh          1974 FALSE       48
```

---

class: center

# Split-apply-combine with `group_by`

&lt;br&gt;
&lt;center&gt;
&lt;img src="images/rstudio-cheatsheet-group_by.png" width="900"&gt;
&lt;/center&gt;

---

## Compute values by group with `group_by`

Compute the mean band member age for **each band**


```r
bands %&gt;%
    mutate(
        age = 2020 - yearOfBirth,
*       mean_age = mean(age)) # This is the mean across both bands
```

```
#&gt; # A tibble: 9 × 8
#&gt;   firstName lastName  yearOfBirth deceased band       instrument   age mean_age
#&gt;   &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt; &lt;lgl&gt;    &lt;chr&gt;      &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;
#&gt; 1 Melanie   Brown            1975 FALSE    spicegirls &lt;NA&gt;          45     60.4
#&gt; 2 Melanie   Chisholm         1974 FALSE    spicegirls &lt;NA&gt;          46     60.4
#&gt; 3 Emma      Bunton           1976 FALSE    spicegirls &lt;NA&gt;          44     60.4
#&gt; 4 Geri      Halliwell        1972 FALSE    spicegirls &lt;NA&gt;          48     60.4
#&gt; 5 Victoria  Beckham          1974 FALSE    spicegirls &lt;NA&gt;          46     60.4
#&gt; 6 John      Lennon           1940 TRUE     &lt;NA&gt;       guitar        80     60.4
#&gt; 7 Paul      McCartney        1942 FALSE    &lt;NA&gt;       bass          78     60.4
#&gt; 8 Ringo     Starr            1940 FALSE    &lt;NA&gt;       drums         80     60.4
#&gt; 9 George    Harrison         1943 TRUE     &lt;NA&gt;       guitar        77     60.4
```

---

## Compute values by group with `group_by`

Compute the mean band member age for each band


```r
bands %&gt;%
    mutate(age = 2020 - yearOfBirth) %&gt;%
*   group_by(band) %&gt;% # Everything after this will be done each band
    mutate(mean_age = mean(age))
```

```
#&gt; # A tibble: 9 × 8
#&gt; # Groups:   band [2]
#&gt;   firstName lastName  yearOfBirth deceased band       instrument   age mean_age
#&gt;   &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt; &lt;lgl&gt;    &lt;chr&gt;      &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;
#&gt; 1 Melanie   Brown            1975 FALSE    spicegirls &lt;NA&gt;          45     45.8
#&gt; 2 Melanie   Chisholm         1974 FALSE    spicegirls &lt;NA&gt;          46     45.8
#&gt; 3 Emma      Bunton           1976 FALSE    spicegirls &lt;NA&gt;          44     45.8
#&gt; 4 Geri      Halliwell        1972 FALSE    spicegirls &lt;NA&gt;          48     45.8
#&gt; 5 Victoria  Beckham          1974 FALSE    spicegirls &lt;NA&gt;          46     45.8
#&gt; 6 John      Lennon           1940 TRUE     &lt;NA&gt;       guitar        80     78.8
#&gt; 7 Paul      McCartney        1942 FALSE    &lt;NA&gt;       bass          78     78.8
#&gt; 8 Ringo     Starr            1940 FALSE    &lt;NA&gt;       drums         80     78.8
#&gt; 9 George    Harrison         1943 TRUE     &lt;NA&gt;       guitar        77     78.8
```

---

class: center

# Summarize data frames with `summarise()`

&lt;br&gt;
&lt;center&gt;
&lt;img src="images/rstudio-cheatsheet-summarise.png" width="900"&gt;
&lt;/center&gt;

---

## Summarize data frames with `summarise()`

Compute the mean band member age for **each band**


```r
bands %&gt;%
    mutate(age = 2020 - yearOfBirth) %&gt;%
    group_by(band) %&gt;%
*   summarise(mean_age = mean(age)) # Drops all variables except for group
```

```
#&gt; # A tibble: 2 × 2
#&gt;   band       mean_age
#&gt;   &lt;chr&gt;         &lt;dbl&gt;
#&gt; 1 spicegirls     45.8
#&gt; 2 &lt;NA&gt;           78.8
```

---

## If you only want a quick count, use `count()`

These do the same thing:

.leftcol[


```r
bands %&gt;%
    group_by(band) %&gt;%
    summarise(n = n())
```

```
#&gt; # A tibble: 2 × 2
#&gt;   band           n
#&gt;   &lt;chr&gt;      &lt;int&gt;
#&gt; 1 spicegirls     5
#&gt; 2 &lt;NA&gt;           4
```

]

.rightcol[


```r
bands %&gt;%
    count(band)
```

```
#&gt; # A tibble: 2 × 2
#&gt;   band           n
#&gt;   &lt;chr&gt;      &lt;int&gt;
#&gt; 1 spicegirls     5
#&gt; 2 &lt;NA&gt;           4
```

]

---

class: inverse, center, middle

# Data Visualization

---

.leftcol[

&lt;img src="images/making_a_ggplot.jpeg" width=600&gt;

]

.rightcol[

# "Grammar of Graphics"

Concept developed by Leland Wilkinson (1999)

**ggplot2** package developed by Hadley Wickham (2005)

]

---

# Making plot layers with ggplot2

&lt;br&gt;

### 1. The data (we'll use `bears`)
### 2. The aesthetic mapping (what goes on the axes?)
### 3. The geometries (points? bars? etc.)

---

# Layer 1: The data

The `ggplot()` function initializes the plot with whatever data you're using

.leftcol[


```r
bears %&gt;% 
  ggplot()
```

]

.rightcol[.blackborder[

&lt;img src="figs/unnamed-chunk-115-1.png" width="504" /&gt;

]]

---

# Layer 2: The aesthetic mapping

The `aes()` function determines which variables will be _mapped_ to the geometries&lt;br&gt;(e.g. the axes)

.leftcol[


```r
bears %&gt;% 
* ggplot(aes(x = year, y = age))
```
]

.rightcol[.blackborder[

&lt;img src="figs/unnamed-chunk-116-1.png" width="504" /&gt;

]]

---

# Layer 3: The geometries

Use `+` to add geometries (e.g. points)

.leftcol[


```r
bears %&gt;% 
  ggplot(aes(x = year, y = age)) +
* geom_point()
```

]

.rightcol[.blackborder[

&lt;img src="figs/unnamed-chunk-117-1.png" width="504" /&gt;

]]

---

# Scatterplots with `geom_point()`

Change the color of all points:

.leftcol[


```r
bears %&gt;% 
  ggplot(aes(x = year, y = age)) +
* geom_point(color = 'blue')
```

]

.rightcol[.blackborder[

&lt;img src="figs/unnamed-chunk-118-1.png" width="504" /&gt;

]]

---

# Scatterplots with `geom_point()`

Map the point color to a **variable**:

.leftcol[


```r
bears %&gt;% 
  ggplot(aes(x = year, y = age)) +
* geom_point(aes(color = gender))
```

Note that `color = gender` is _inside_ `aes()`

]

.rightcol[.blackborder[

&lt;img src="figs/unnamed-chunk-119-1.png" width="504" /&gt;

]]

---

## Make bar charts with `geom_col()`

.leftcol[


```r
bears %&gt;%
* count(month) %&gt;%
  ggplot() +
  geom_col(aes(x = month, y = n))
```

]

.rightcol[

&lt;img src="figs/unnamed-chunk-120-1.png" width="504" style="display: block; margin: auto;" /&gt;

]

---

### Change bar width:  `width`
### Change bar color: `fill`
### Change bar outline: `color`

.leftcol[


```r
bears %&gt;%
  count(month) %&gt;%
  ggplot() +
  geom_col(
    mapping = aes(x = month, y = n),
*   width = 0.7,
*   fill = "blue",
*   color = "red"
  )
```

]

.rightcol[

&lt;img src="figs/unnamed-chunk-121-1.png" width="504" style="display: block; margin: auto;" /&gt;

]

---

## Rearrange bars by reordering the factors

.leftcol[


```r
bears %&gt;%
  count(month) %&gt;%
  ggplot() +
  geom_col(
    aes(
*     x = reorder(month, n),
      y = n
    )
  )
```

]

.rightcol[

&lt;img src="figs/unnamed-chunk-122-1.png" width="504" style="display: block; margin: auto;" /&gt;

]

---

class: inverse, center, middle

# Programming with Data

---

# Convert this to a function

.leftcol[

Single-use pipeline


```r
diamonds %&gt;%
  group_by(color) %&gt;%
  summarise(
    n = n(),
    mean = mean(price),
    sd = sd(price)
  )
```

```
#&gt; # A tibble: 7 × 4
#&gt;   color     n  mean    sd
#&gt;   &lt;ord&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 D      6775 3170. 3357.
#&gt; 2 E      9797 3077. 3344.
#&gt; 3 F      9542 3725. 3785.
#&gt; 4 G     11292 3999. 4051.
#&gt; 5 H      8304 4487. 4216.
#&gt; 6 I      5422 5092. 4722.
#&gt; 7 J      2808 5324. 4438.
```

]

--

.rightcol[

As a function by "embracing" variable 🤗


```r
my_summary &lt;- function(df, group, var) {
  df %&gt;%
*   group_by({{ group }}) %&gt;%
    summarise(
      n = n(),
*     mean = mean({{ var }}),
*     sd = sd({{ var }})
    ) 
}
```

]

---

### Use it on a different data frame!

.leftcol[


```r
library(palmerpenguins)

my_summary(penguins, sex, body_mass_g)
```

```
#&gt; # A tibble: 3 × 4
#&gt;   sex        n  mean    sd
#&gt;   &lt;fct&gt;  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 female   165 3862.  666.
#&gt; 2 male     168 4546.  788.
#&gt; 3 &lt;NA&gt;      11   NA    NA
```

]

.rightcol[


```r
my_summary(penguins, species, bill_length_mm)
```

```
#&gt; # A tibble: 3 × 4
#&gt;   species       n  mean    sd
#&gt;   &lt;fct&gt;     &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 Adelie      152  NA   NA   
#&gt; 2 Chinstrap    68  48.8  3.34
#&gt; 3 Gentoo      124  NA   NA
```

]

---

class: center, middle 

## Iterating on data with `purrr`

&lt;center&gt;
&lt;img src="https://purrr.tidyverse.org/logo.png" width=200&gt;
&lt;/center&gt;

Loaded automatically with `library(tidyverse)`

---

class: center, middle

## `purrr::map(x, f, ...)`

&lt;br&gt;

## for every element of `x` do `f`

---

background-image: url("images/lego1.jpeg")
background-size: contain
class: center

&lt;br&gt;

## `x = minis`

## `f = add_antenna`

---

background-image: url("images/lego2.jpeg")
background-size: contain
class: center

&lt;br&gt;

## `map(minis, add_antenna)`

---

class: center 
background-color: #fff

## for every element of `x` do `f`

&lt;center&gt;
&lt;img src="images/map.png" width=650&gt;
&lt;/center&gt;

---

# Some examples

What will this return?


```r
# eval: false

map(1:3, \(x) x %% 2 == 0)
```

```
#&gt; [[1]]
#&gt; [1] FALSE
#&gt; 
#&gt; [[2]]
#&gt; [1] TRUE
#&gt; 
#&gt; [[3]]
#&gt; [1] FALSE
```

--


```r
map(1:3, \(x) x %% 2 == 0)
```

```
#&gt; [[1]]
#&gt; [1] FALSE
#&gt; 
#&gt; [[2]]
#&gt; [1] TRUE
#&gt; 
#&gt; [[3]]
#&gt; [1] FALSE
```

---

# Some examples

What will this return?


```r
# eval: false

sum(map_int(1:3, \(x) x %% 2 == 0))
```

```
#&gt; [1] 1
```

--


```r
sum(map_int(1:3, \(x) x %% 2 == 0))
```

```
#&gt; [1] 1
```

---

class: inverse, center, middle

# Webscraping

---

## There will be a bonus question on scraping a website

## General tips:

`html_element()`:

- Know when to use `html_element()` vs `html_elements()`
- **Warning**: ChatGPT doesn't know `html_element()` - it only knows `html_node()`

`html_table()`:

- If you use `html_table()`, remember it returns a **list** of tables.
- Usually you want the first table, something like this:


```r
tables &lt;- html %&gt;% html_table()
df &lt;- tables[[1]]
```

---

class: inverse, center, middle

# Monte Carlo

---

# Monte Carlo Simulation: _Computing Probability_

### General process:

- Run a series of trials.
- In each trial, simulate an event (e.g. a coin toss, a dice roll, etc.).
- Count the number of "successful" trials
&lt;br&gt;&lt;br&gt;

--

### `\(\frac{\text{# Successful Trials}}{\text{# Total Trials}}\)` = Observed Odds `\(\simeq\)` Expected Odds

--

### **Law of large numbers**:&lt;br&gt;As _N_ increases, Observed Odds <svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg> Expected Odds

---

### Discrete, **Independent** Events: `sample(replace = TRUE)`

What is the probability of rolling a 6-sided dice 3 times&lt;br&gt;and getting the sequence 1, 3, 5?


```r
library(tidyverse)

dice &lt;- c(1, 2, 3, 4, 5, 6)
N &lt;- 10000

rolls &lt;- tibble(
  roll1 = sample(x = dice, size = N, replace = T),
  roll2 = sample(x = dice, size = N, replace = T),
  roll3 = sample(x = dice, size = N, replace = T)
)

successes &lt;- rolls %&gt;%
  filter(roll1 == 1 &amp; roll2 == 3 &amp; roll3 == 5)

nrow(successes) / N
```

```
#&gt; [1] 0.0054
```

---

### Discrete, **Dependent** Events: `sample(replace = FALSE)`

What are the odds that 3 cards drawn from a 52-card deck will sum to 13?

Repeat the 3-card draw _N_ times:


```r
deck &lt;- rep(c(seq(1, 10), 10, 10, 10), 4) 

N &lt;- 100000
count &lt;- 0
for (i in 1:N) {
*  draw &lt;- sample(x = deck, size = 3, replace = FALSE)
   if (sum(draw) == 13) {
      count &lt;- count + 1
   }
}

count / N # Compute the probability
```

```
#&gt; [1] 0.03642
```

---

class: inverse, center, middle

# Begin list of all problems solved in class

---

class: inverse

## General function writing

.leftcol[

`eggCartons(eggs)`: Write a function that reads in a non-negative number of eggs and prints the number of egg cartons required to hold that many eggs. Each egg carton holds one dozen eggs, and you cannot buy fractional egg cartons.

- eggCartons(0) == 0
- eggCartons(1) == 1
- eggCartons(12) == 1
- eggCartons(25) == 3

]

.rightcol[

`militaryTimeToStandardTime(n)`: Write a function that takes an integer between 0 and 23 (representing the hour in [military time](http://militarytimechart.com/)), and returns the same hour in standard time.

- militaryTimeToStandardTime(0) == 12
- militaryTimeToStandardTime(3) == 3
- militaryTimeToStandardTime(12) == 12
- militaryTimeToStandardTime(13) == 1
- militaryTimeToStandardTime(23) == 11

]

---

class: inverse

# Number chopping

.leftcol[
`onesDigit(x)`: Write a function that takes an integer and returns its ones digit.

Tests:
- onesDigit(123) == 3
- onesDigit(7890) == 0
- onesDigit(6) == 6
- onesDigit(-54) == 4
]

.rightcol[
`tensDigit(x)`: Write a function that takes an integer and returns its tens digit.

Tests:
- tensDigit(456) == 5
- tensDigit(23) == 2
- tensDigit(1) == 0
- tensDigit(-7890) == 9
]

---

class: inverse

# Top-down design

Create a function, `isRightTriangle(a, b, c)` that returns `TRUE` if the triangle formed by the lines of length `a`, `b`, and `c` is a right triangle and `FALSE` otherwise. Use the `hypotenuse(a, b)` function in your solution. **Hint**: you may not know which value (`a`, `b`, or `c`) is the hypotenuse.

.leftcol[.code80[

```r
hypotenuse &lt;- function(a, b) {
    return(sqrt(sumOfSquares(a, b)))
}
```

```r
sumOfSquares &lt;- function(a, b) {
    return(a^2 + b^2)
}
```
]]

---

class: inverse

# Conditionals (if / else)

`getType(x)`: Write the function `getType(x)` that returns the type of the data (either `integer`, `double`, `character`, or `logical`). Basically, it does the same thing as the `typeof()` function (but you can't use `typeof()` in your solution).

- `getType(3) == "double"`
- `getType(3L) == "integer"`
- `getType("foo") == "character"`
- `getType(TRUE) == "logical"`

---

class: inverse

# Conditionals (if / else)

For each of the following functions, start by writing a test function that tests the function for a variety of values of inputs. Consider cases that you might not expect!

.leftcol[
`isFactor(f, n)`: Write the function `isFactor(f, n)` that takes two integer values and returns `TRUE` if `f` is a factor of `n`, and `FALSE` otherwise. Note that every integer is a factor of `0`. Assume `f` and `n` will only be numeric values, e.g. `2` is a factor of `6`.
]

.rightcol[
`isMultiple(m, n)`: Write the function `isMultiple(m, n)` that takes two integer values and returns `TRUE` if `m` is a multiple of `n` and `FALSE` otherwise. Note that `0` is a multiple of every integer other than itself. Hint: You may want to use the `isFactor(f, n)` function you just wrote above. Assume `m` and `n` will only be numeric values.
]

---

class: inverse

# Conditionals (if / else)

Write the function `getInRange(x, bound1, bound2)` which takes 3 numeric values: `x`, `bound1`, and `bound2` (`bound1` is not necessarily less than `bound2`). If `x` is between the two bounds, just return `x`, but if `x` is less than the lower bound, return the lower bound, or if `x` is greater than the upper bound, return the upper bound. For example:

- `getInRange(1, 3, 5)` returns `3` (the lower bound, since 1 is below [3,5])
- `getInRange(4, 3, 5)` returns `4` (the original value, since 4 is between [3,5])
- `getInRange(6, 3, 5)` returns `5` (the upper bound, since 6 is above [3,5])
- `getInRange(6, 5, 3)` returns `5` (the upper bound, since 6 is above [3,5])

**Bonus**: Re-write `getInRange(x, bound1, bound2)` without using conditionals

---

class: inverse

## `for` loops

.font80[
`sumFromMToN(m, n)`: Write a function that sums the total of the integers between `m` and `n`.&lt;br&gt;**Challenge**: Try solving this without a loop!

- `sumFromMToN(5, 10) == (5 + 6 + 7 + 8 + 9 + 10)`
- `sumFromMToN(1, 1) == 1`

`sumEveryKthFromMToN(m, n, k)`: Write a function to sum every kth integer from `m` to `n`.

- `sumEveryKthFromMToN(1, 10, 2) == (1 + 3 + 5 + 7 + 9)`
- `sumEveryKthFromMToN(5, 20, 7) == (5 + 12 + 19)`
- `sumEveryKthFromMToN(0, 0, 1) == 0`

`sumOfOddsFromMToN(m, n)`: Write a function that sums every _odd_ integer between `m` and `n`.

- `sumOfOddsFromMToN(4, 10) == (5 + 7 + 9)`
- `sumOfOddsFromMToN(5, 9) == (5 + 7 + 9)`
]

---

class: inverse

## `for` loop with `break` &amp; `next`

`sumOfOddsFromMToNMax(m, n, max)`: Write a function that sums every _odd_ integer from `m` to `n` until the sum is less than the value `max`. Your solution should use both `break` and `next` statements.

- `sumOfOddsFromMToNMax(1, 5, 4) == (1 + 3)`
- `sumOfOddsFromMToNMax(1, 5, 3) == (1)`
- `sumOfOddsFromMToNMax(1, 5, 10) == (1 + 3 + 5)`

---

class: inverse

## `while` loops

.leftcol[
`isMultipleOf4Or7(n)`: Write a function that returns `TRUE` if `n` is a multiple of 4 or 7 and `FALSE` otherwise.

- `isMultipleOf4Or7(0) == FALSE`
- `isMultipleOf4Or7(1) == FALSE`
- `isMultipleOf4Or7(4) == TRUE`
- `isMultipleOf4Or7(7) == TRUE`
- `isMultipleOf4Or7(28) == TRUE`
]

.rightcol[
`nthMultipleOf4Or7(n)`: Write a function that returns the nth positive integer that is a multiple of either 4 or 7.

- `nthMultipleOf4Or7(1) == 4`
- `nthMultipleOf4Or7(2) == 7`
- `nthMultipleOf4Or7(3) == 8`
- `nthMultipleOf4Or7(4) == 12`
- `nthMultipleOf4Or7(5) == 14`
- `nthMultipleOf4Or7(6) == 16`
]

---

class: inverse

## Loops / Vectors

.leftcol[
`isPrime(n)`: Write a function that takes a non-negative integer, `n`, and returns `TRUE` if it is a prime number and `FALSE` otherwise. Use a loop or vector:

- `isPrime(1) == FALSE`
- `isPrime(2) == TRUE`
- `isPrime(7) == TRUE`
- `isPrime(13) == TRUE`
- `isPrime(14) == FALSE`
]

.rightcol[
`nthPrime(n)`: Write a function that takes a non-negative integer, `n`, and returns the nth prime number, where `nthPrime(1)` returns the first prime number (2). Hint: use a while loop!

- `nthPrime(1) == 2`
- `nthPrime(2) == 3`
- `nthPrime(3) == 5`
- `nthPrime(4) == 7`
- `nthPrime(7) == 17`
]

---

class: inverse

# Vectors

.font80[
`reverse(x)`: Write a function that returns the vector in reverse order. You cannot use the `rev()` function.

- `all(reverseVector(c(5, 1, 3)) == c(3, 1, 5))`
- `all(reverseVector(c('a', 'b', 'c')) == c('c', 'b', 'a'))`
- `all(reverseVector(c(FALSE, TRUE, TRUE)) == c(TRUE, TRUE, FALSE))`


`alternatingSum(a)`: Write a function that takes a vector of numbers `a` and returns the alternating sum, where the sign alternates from positive to negative or vice versa.

- `alternatingSum(c(5,3,8,4)) == (5 - 3 + 8 - 4)`
- `alternatingSum(c(1,2,3)) == (1 - 2 + 3)`
- `alternatingSum(c(0,0,0)) == 0`
- `alternatingSum(c(-7,5,3)) == (-7 - 5 + 3)`
]

---

class: inverse

# Strings

1) `reverseString(s)`: Write a function that returns the string `s` in reverse order.

- `reverseString("aWordWithCaps") == "spaChtiWdroWa"`
- `reverseString("abcde") == "edcba"`
- `reverseString("") == ""`

2) `isPalindrome(s)`: Write a function that returns `TRUE` if the string `s` is a [Palindrome](https://en.wikipedia.org/wiki/Palindrome) and `FALSE` otherwise.

- `isPalindrome("abcba") == TRUE`
- `isPalindrome("abcb") == FALSE`
- `isPalindrome("321123") == TRUE`

---

class: inverse

# Strings

.font90[

1) `sortString(s)`: Write the function `sortString(s)` that takes a string `s` and returns back an alphabetically sorted string.

- `sortString("cba") == "abc"`
- `sortString("abedhg") == "abdegh"`
- `sortString("AbacBc") == "aAbBcc"`

2) `areAnagrams(s1, s2)`: Write the function `areAnagrams(s1, s2)` that takes two strings, `s1` and `s2`, and returns `TRUE` if the strings are [anagrams](https://en.wikipedia.org/wiki/Anagram), and `FALSE` otherwise. **Treat lower and upper case as the same letters**.

- `areAnagrams("", "") == TRUE`
- `areAnagrams("aabbccdd", "bbccddee") == FALSE`
- `areAnagrams("TomMarvoloRiddle", "IAmLordVoldemort") == TRUE`

]

---

class: inverse

## Data Frame Basics

Answer these questions using the `beatles` data frame:

1. Create a new column, `playsGuitar`, which is `TRUE` if the band member plays the guitar and `FALSE` otherwise.
2. Filter the data frame to select only the rows for the band members who have four-letter first names.
3. Create a new column, `fullName`, which contains the band member's first and last name separated by a space (e.g. `"John Lennon"`)

---

class: inverse

### Data Wrangling: `select()` &amp; `filter()`

.font90[

1) Create the data frame object `df` by using `here()` and `read_csv()` to load the `wildlife_impacts.csv` file in the `data` folder.

2) Use the `df` object and the `select()` and `filter()` functions to answer the following questions:

- Create a new data frame, `df_birds`, that contains only the variables (columns) about the species of bird.
- Create a new data frame, `dc`, that contains only the observations (rows) from DC airports.
- Create a new data frame, `dc_birds_known`, that contains only the observations (rows) from DC airports and those where the species of bird is known.
- How many _known_ unique species of birds have been involved in accidents at DC airports?

]

---

class: inverse

### Data Wrangling: `select()` &amp; `filter()` w/Pipes

.font90[

1) Create the data frame object `df` by using `here()` and `read_csv()` to load the `wildlife_impacts.csv` file in the `data` folder.

2) Use the `df` object and `select()`, `filter()`, and `%&gt;%` to answer the following questions:

- Create a new data frame, `dc_dawn`, that contains only the observations (rows) from DC airports that occurred at dawn.
- Create a new data frame, `dc_dawn_birds`, that contains only the observations (rows) from DC airports that occurred at dawn and only the variables (columns) about the species of bird.
- Create a new data frame, `dc_dawn_birds_known`, that contains only the observations (rows) from DC airports that occurred at dawn and only the variables (columns) about the KNOWN species of bird.
- How many _known_ unique species of birds have been involved in accidents at DC airports at dawn?

]

---

class: inverse

### Data Wrangling: `mutate()` &amp; `arrange()`

.font90[

1) Create the data frame object `df` by using `here()` and `read_csv()` to load the `wildlife_impacts.csv` file in the `data` folder.

2) Use the `df` object with `%&gt;%` and `mutate()` to create the following new variables:

- `height_miles`: The `height` variable converted to miles (Hint: there are 5,280 feet in a mile).
- `cost_mil`: Is `TRUE` if the repair costs was greater or equal to $1 million, `FALSE` otherwise.
- `season`: One of four seasons based on the `incident_month` variable:

  - `spring`: March, April, May
  - `summer`: June, July, August
  - `fall`: September, October, November
  - `winter`: December, January, February

]

---

class: inverse

### Data Wrangling: `group_by()` &amp; `summarise()`

.font90[

1) Create the data frame object `df` by using `here()` and `read_csv()` to load the `wildlife_impacts.csv` file in the `data` folder.

2) Use the `df` object and `group_by()`, `summarise()`, `count()`, and `%&gt;%` to answer the following questions:

- Create a summary data frame that contains the mean `height` for each different time of day.
- Create a summary data frame that contains the maximum `cost_repairs_infl_adj` for each year.
- Which _month_ has had the greatest number of reported incidents?
- Which _year_ has had the greatest number of reported incidents?

]

---

class: inverse

## Data Viz: `geom_point()`

Use the `birds` data frame to create the following plots

.leftcol[

&lt;img src="figs/ggpoint_p1-1.png" width="504" /&gt;

]

.rightcol[

&lt;img src="figs/ggpoint_p2-1.png" width="504" /&gt;

]

---

## Data Viz: `geom_col()`

Use the `bears` and `birds` data frame to create the following plots

.leftcol[

&lt;img src="figs/ggbar_p1-1.png" width="504" /&gt;

]

.rightcol[

&lt;img src="figs/ggbar_p2-1.png" width="504" /&gt;

]

---

class: inverse

## Writing Data Functions 1

.leftcol[


```r
my_subset &lt;- function(df, condition, cols)
```

Returns a subset of `df` by filtering the rows based on `condition` and only includes the select `cols`. Example:




```r
nycflights13::flights %&gt;% 
  my_subset(
    condition = month == 12, 
    cols = c("carrier", "flight")
  )
```


```
#&gt; # A tibble: 5 × 2
#&gt;   carrier flight
#&gt;   &lt;chr&gt;    &lt;int&gt;
#&gt; 1 B6         745
#&gt; 2 B6         839
#&gt; 3 US        1895
#&gt; 4 UA        1487
#&gt; 5 AA        2243
```

]

.rightcol[


```r
count_p &lt;- function(df, group)
```

Returns a summary data frame of the count of rows in `df` by `group` as well as the percentage of those counts.




```r
nycflights13::flights %&gt;%
  count_p(carrier)
```


```
#&gt; # A tibble: 6 × 3
#&gt;   carrier     n      p
#&gt;   &lt;chr&gt;   &lt;int&gt;  &lt;dbl&gt;
#&gt; 1 UA      58665 0.174 
#&gt; 2 B6      54635 0.162 
#&gt; 3 EV      54173 0.161 
#&gt; 4 DL      48110 0.143 
#&gt; 5 AA      32729 0.0972
#&gt; 6 MQ      26397 0.0784
```

]

---

class: inverse

## Writing Data Functions 2

Write the function `filtered_scatter` which plots a scatterplot based on a condition, then use it for the two examples below.


```r
filtered_scatter &lt;- function(df, condition, x, y)
```



.leftcol[


```r
filtered_scatter(
  penguins, sex == "male", 
  x = body_mass_g, y = bill_length_mm)
```

&lt;img src="figs/unnamed-chunk-146-1.png" width="360" /&gt;

]

.rightcol[


```r
filtered_scatter(
  penguins, species == "Gentoo", 
  x = body_mass_g, y = flipper_length_mm)
```

&lt;img src="figs/unnamed-chunk-147-1.png" width="360" /&gt;

]

---

class: inverse
 
## Monte Carlo: Coins &amp; Dice

.leftcol70[

Using the `sample()` function, conduct a monte carlo simulation to estimate the answers to these questions:

- If you flipped a coin 3 times in a row, what is the probability that you'll get three "tails" in a row?
- If you rolled 2 dice, what is the probability that you'll get "snake-eyes" (two 1's)?
- If you rolled 2 dice, what is the probability that you'll get an outcome that sums to 8?

]

---

class: inverse

## Monte Carlo: Cards

Use the `sample()` function and a monte carlo simulation to estimate the answers to these questions:

.leftcol[

- What are the odds that four cards drawn from a 52-card deck will have the same suit?
- What are the odds that five cards drawn from a 52-card deck will sum to a prime number?

- Aces = 1
- Jack = 10
- Queen = 10
- King = 10

]

.rightcol[

**Hint**: use `isPrime()` to help:


```r
isPrime &lt;- function(n) {
    if (n == 2) { return(TRUE) }
    for (i in seq(2, n-1)) {
        if (n %% i == 0) {
            return(FALSE)
        }
    }
    return(TRUE)
}
```

]

---

class: inverse

## Monte Carlo: Estimate `\(\pi\)`

.leftcol30[

&lt;img src="figs/cirle-points-1.png" width="360" /&gt;

`\(\pi = 4 \left( \frac{A_{circle}}{A_{square}} \right)\)`

]

.rightcol70[.font90[

1. Create a tibble with variables `x` and `y` that each contain 10,000 random points between -1 and 1, representing the (x, y) coordinates to a random point inside a square of side length 2 centered at `(x, y) = (0, 0)`. **Hint**: use `runif()`

2. Create a new column, `radius`, that is equal to the distance to each `(x, y)` point from the center of the square.

3. Create a new column, `pointInCircle`, that is `TRUE` if the point lies _within_ the circle inscribed in the square, and `FALSE` otherwise.

4. Create the scatterplot on the left (don't worry about the precise colors, dimensions, etc.).

5. Estimate `\(\pi\)` by multiplying 4 times the ratio of points inside the circle to the total number of points

]]

---

class: inverse

## Monte Carlo: Monte Hall Problem

.leftcol40[

&lt;img src="images/monte_hall.jpg" width="80%" /&gt;

1. You choose door 1, 2, or 3
2. One door is removed
3. Should you swap doors?

]

.rightcol60[.font90[

In this simulation, the prize is always behind door #1:

- If you choose door #1, you must KEEP it to win.
- If you choose door #2 or #3, you must SWAP to win.

1) Create the tibble, `choices`, with two variables:
- `door` contains the first door chosen (`1`, `2`, or `3`)
- `swap` contains a logical (`TRUE` or `FALSE`) for whether the contestant swaps doors. **Hint**: use `sample()`

2) Create a new tibble, `wins`, which contains only the rows from `choices` that resulted in a win.

3) Compute the percentage of times the contestant won after swapping doors.

]]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
